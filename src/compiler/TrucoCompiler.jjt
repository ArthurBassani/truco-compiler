
options
{
  static = true;
  DEBUG_PARSER = true;
  
}

PARSER_BEGIN(TrucoCompiler)

package compiler;

import recovery.*;
import error.*;

public class TrucoCompiler
{
  static boolean lastRecoverySuccessful = false;
  public static void main(String args []) throws ParseException
  {
    TrucoCompiler parser = new TrucoCompiler(System.in);
    while (true)
    {
      System.out.println("Digite Entrada:");
      System.out.print("-> ");
      
      try
      {
       	SimpleNode n = parser.Start();
      }
      catch(ParseException e)
      {
		Token token = e.currentToken.next;
		int linha = token.beginLine;
		int coluna = token.beginColumn;

		int[][] expectedSequences = e.expectedTokenSequences;
	    String[] esperados = new String[expectedSequences.length];
	    for (int i = 0; i < expectedSequences.length; i++) {
	        StringBuilder sb = new StringBuilder();
	        for (int kind : expectedSequences[i]) {
	            sb.append(TrucoCompiler.tokenImage[kind]).append(" ");
	        }
	        esperados[i] = sb.toString().trim();
	    }

        System.out.println("");
        System.out.println("Algo de errado não está certo...");
        System.out.println("Erro sintático parceiro:");
        System.out.println("Linha: " + linha);
        System.out.println("Coluna: " + coluna);
        System.out.println("Tu mandou essa bomba: " + token.image);

		if(esperados != null) {
       		System.out.println("Tava esperando tipo: ");
			for(int i = 0; i < esperados.length; i++){
       			System.out.println(esperados[i]);
			}
		}
		break;
      }
      catch (Error e)
      {
		
        System.out.println("Algo de errado não está certo...");
		System.out.println(ErrorMessages.generateLexicalError(e));
        break;
      }
      finally
      {
        parser.ReInit(System.in);
      }
    }
  }
 static public String im(int x)
  {
    int k;
	String s;
    s = tokenImage[x];
    k = s.lastIndexOf("\"");
    try {
      s = s.substring(1,k);
    }
   catch (StringIndexOutOfBoundsException e)
	   {}
   return s;
  }
	
  static Token lastError = null;
  static boolean eof;    // variável que indica se EOF foi alcançado
	
  // o método abaixo consome tokens até alcançar um que pertença ao conjunto
  // de sincronização
  static boolean consumeUntil(RecoverySet g,
	                 ParseException e,
	                 String met) throws ParseEOFException,
	                                    ParseException
  {
	Token tok;
	System.out.println();
	System.out.println("*** " + met + " ***");
	System.out.println("     Conjunto de sincronização: " + g);

	ErrorHandler.addError("\n*** Recuperando de erro em: " + met + " ***");
    ErrorHandler.addError("Conjunto de sincronização: " + g);
		
	if (g == null) throw e; // se o conjunto é null, propaga a exceção
	
	tok = getToken(1); // pega token corrente
	while ( ! eof )	{ // se não chegou ao fim do arquivo
	  if ( g.contains(tok.kind)) {//achou um token no conjunto
	    System.out.println("     Encontrado token de sincronização: " + 
	                       im(tok.kind));
		ErrorHandler.addError("✓ Encontrado token de sincronização: " + im(tok.kind));
        lastRecoverySuccessful = true;
	    return true;
	  }
	  ErrorHandler.addError("✗ Ignorando token: " + im(tok.kind));
	  System.out.println("     Ignorando o token: " + im(tok.kind));
	  getNextToken();     // pega próximo token       
      tok = getToken(1);
	  if (tok.kind == EOF && ! g.contains(EOF) ) // fim da entrada?   
	      eof = true;
	}
    if ( tok != lastError)  {
	  System.out.println(e.getMessage());
	  ErrorHandler.addError("\n" + formatErrorMessage(e));
	  lastError = tok;
	}
	
    lastRecoverySuccessful = false;
	if ( eof )
	  throw new ParseEOFException("Encontrei EOF onde não deveria.");

	return false;
  }

  static String formatErrorMessage(ParseException e) {
    Token token = e.currentToken.next;
    if (token == null) token = e.currentToken;
    
    StringBuilder sb = new StringBuilder();
    sb.append("ERRO SINTÁTICO:\n");
    sb.append("  Linha: ").append(token.beginLine).append("\n");
    sb.append("  Coluna: ").append(token.beginColumn).append("\n");
    sb.append("  Token encontrado: \"").append(token.image).append("\"\n");
    
    if (e.expectedTokenSequences != null && e.expectedTokenSequences.length > 0) {
        sb.append("  Esperava um dos seguintes:\n");
        for (int[] seq : e.expectedTokenSequences) {
            if (seq.length > 0) {
                sb.append("    • ").append(im(seq[0])).append("\n");
            }
        }
    }
    
    return sb.toString();
}
  
}

PARSER_END(TrucoCompiler)

TOKEN_MGR_DECLS : {
    public void LexicalError(boolean EOFSeen, int lexState, int errorLine,
                             int errorColumn, String errorAfter, char curChar) {
        throw new LexicalException(errorLine, errorColumn, curChar, errorAfter);
    }
}

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| < "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n") >
}

TOKEN :
{

  < STARTPROGRAMA	:		"tresehojogo" 			>

| < ABRECHA			:		"desce" 				>
| < FECHAVE			:		"sobe"  				>

| < ABREPAR			:		"passa"					>
| < FECHAPAR		:		"sinal" 				>

| < DECLASSE		:		"carteado" 				>
| <	MODPRIVADO		:		"privado" 				>
| <	MODPUBLICO		:		"publico" 				>
| < THIS			:		"eu" 					>
| < NEW 			:		"novinho" 				>

| < DECLFUNC 		: 		"vai"					>
| < CHAMAFUNC		:		"vem" 					>
| < RETURN			:		"facao" 				>

| < ATRIVAR			:		"receba"				>
| < FIMINST			:		"pato" 					>

| < TIPOINT   	 	: 		"copa"				    >
| < TIPODOUBLE     	: 		"gato"     				>
| < TIPOBOOLEAN   	: 		"mole"	    			>
| < TIPOSTRING 		:		"espadilha"				>
| < TIPOVETOR		:		"manilha" 				>

| < BOOLTRUE		:		"joga"					>
| < BOOLFALSE		:		"corre"					>
| < NULL			:		"nada" 					>
| < ACESSVETOR		:		":" 					>

| < SINALDECIMAL	:		"." 					>
| < SINALSTRING		:		"'"						>


| < SOMA 			: 		"mais" 					>
| < SUBTRACAO 		: 		"menos" 				>
| < DIVISAO 		: 		"div" 					>
| < MULTIPLICACAO 	: 		"mul" 					>

| < OPAND			:		"e"						>
| < OPOR			:		"ou"					>
| < OPMAIOR      	: 		"maior" 				>
| < OPMENOR      	: 		"menor" 				>
| < OPIGUAL      	: 		"igual"					>
| < OPDIF        	: 		"diferente"				>

| < COND			:		"parceiro" 				>
| < FOR 			:		"torna"					>
| < REP3			:		"come3" 				>

| < IDENT 			:		( <LETRA> )( <LETRA> | <DIGITO> )* 		>
| < LETRA			:		[ "A"-"Z" ] | [ "a"-"z" ]				>
| < STRING 			: 		"'" (~["'", "\n", "\r"])+ "'" 			>

| < DECIMAL			:		( <INTEIRO> <SINALDECIMAL> <INTEIRO> )	>
| < INTEIRO 		: 		( <DIGITO> )+ 			>
| < #DIGITO 		: 		[ "0"-"9" ] 			>


}

SimpleNode Start() #Start :
{ }
{
	program()
	{ return jjtThis; }
}

void program():
{ RecoverySet sinc = Follow.main; }
{
  try {
    startPrograma() abreChave()
		blocos()
  	fechaChave()
  } catch(ParseException e) {
	ErrorHandler.addError(formatErrorMessage(e));
	consumeUntil(sinc, e, "main");
  }
}

// OPERADORES

void opArit() :
{}
{
	( soma()
	| subtracao()
	| multiplicacao()
	| divisao()
	)
}

void opLog() :
{}
{
	( opMaior()
	| opMenor()
	| opIgual()
	| opDif()
	)
}

void opCond() :
{}
{
	( opAnd()
	| opOr()
	)
}

// EXPRESSÕES

void expArit() :
{}
{
   termo() ( opArit() ( abrePar() expArit() fechaPar() | termo() ) )*
}

void expLog() :
{}
{
 	expArit() opLog() expArit()
}

void expAritOrLog():
{ }
{
	expArit() [opLog() expArit()]
}

void expCond():
{}
{
   expLog() (opCond() ( abrePar() expCond() fechaPar() | expLog()))*
}

// TIPOS DE DADOS

void tipoDado() :
{}
{
  	( tipoInt()
  	| tipoDouble()
  	| tipoBoolean()
  	| tipoString()
  	| tipoVetor()
  	)
}


void tipoVetor() :
{}
{
	tVetor() tipoDado()
}

// INDENTIFICADORES E DECLARAÇÃO

void identificador() :
{}
{
	ident() [ acessaVetor() ] ( atribui() fimInst() )
}

void acessaVetor():
{}
{
	 acessVetor() ( ident() | inteiro() )
}

void declVar() :
{}
{
  tipoDado() ident() [ atribui() ] fimInst()
}

void numero() :
{}
{
	[ soma() | subtracao() ] ( decimal() | inteiro() )
}

void termo() :
{ RecoverySet sinc = Follow.termo; }
{
  try {
  	( ident() [ acessaVetor() ]
  	| nulo()
  	| boolTrue()
	| boolFalse()
	| string()
	| numero()
	| _chamaFuncao()
	)
  } catch(ParseException e) {
    ErrorHandler.addError(formatErrorMessage(e));
	consumeUntil(sinc, e, "termo");
  }
}

// ATRIBUIÇÕES

void atribui() :
{}
{
	atrivar() ( atribuiVetor() | expAritOrLog() )
}

void atribuiVetor() :
{}
{
	abreChave() termo() ( fimInst() termo() )* fechaChave()
}

// CONDICIONAL

void condicional():
{}
{
	cond() abrePar() expCond() fechaPar() abreChave()
		blocos()
	 fechaChave()
}

// LAÇOS

void lacoRep() :
{}
{
   tFor() abrePar() bloco() expLog() fimInst() bloco() fechaPar()
  	abreChave()
		blocos()
	 fechaChave()
}
 
void lacoRep3() :
{}
{
	tRep3() abreChave() blocos() fechaChave()
}

// FUNÇÕES

void retorna() :
{}
{
	tReturn() expArit() fimInst()
}

void _chamaFuncao():
{}
{
  chamaFunc() ident() abrePar() termo() ( fimInst() termo() )* fechaPar()
}

void chamaFuncao() :
{}
{
  _chamaFuncao() fimInst()
}

void declFuncao() :
{}
{
  tDeclFunc() tipoDado() ident()
  		abrePar() (declVar())* fechaPar()
		abreChave() blocos() fechaChave()
}


// BLOCOS

void blocos():
{ RecoverySet sinc = Follow.blocos; }
{
  	(
	  try {
	  	bloco()
	  } catch(ParseException e) {
	    ErrorHandler.addError(formatErrorMessage(e));
		consumeUntil(sinc, e, "blocos");
	  }
 	)*
}

void bloco() :
{}
{
	  ( declVar()
	  | identificador()
	  | condicional()
	  | lacoRep()
	  | lacoRep3()
	  | declFuncao()
	  | retorna()
	  | chamaFuncao()
	  )
}

// TOKENS

void startPrograma(): { } { < STARTPROGRAMA > }
void abreChave(): { } { < ABRECHA > }
void fechaChave(): { } { < FECHAVE > }
void soma(): { } { < SOMA > }
void subtracao(): { } { < SUBTRACAO > }
void multiplicacao(): { } { < MULTIPLICACAO > }
void divisao(): { } { < DIVISAO > }
void opMaior(): { } { < OPMAIOR > }
void opMenor(): { } { < OPMENOR > }
void opIgual(): { } { < OPIGUAL > }
void opDif(): { } { < OPDIF > }
void abrePar(): { } { < ABREPAR > }
void fechaPar(): { } { < FECHAPAR > }
void tipoInt(): { } { < TIPOINT > }
void tipoDouble(): { } { < TIPODOUBLE > }
void tipoBoolean(): { } { < TIPOBOOLEAN > }
void tipoString(): { } { < TIPOSTRING > }
void tVetor(): { } { < TIPOVETOR > }
void ident(): { } { < IDENT > }
void fimInst(): { } { < FIMINST > }
void decimal(): { } { < DECIMAL > }
void inteiro(): { } { < INTEIRO > }
void nulo(): { } { < NULL > }
void boolTrue(): { } { < BOOLTRUE > }
void boolFalse(): { } { <  BOOLFALSE > }
void string(): { } { < STRING > }
void atrivar(): { } { < ATRIVAR > }
void cond(): { } { < COND > }
void tFor(): { } { <FOR> }
void tReturn(): { } { < RETURN > }
void chamaFunc(): { } {< CHAMAFUNC > }
void tDeclFunc(): { } { < DECLFUNC > }
void modPrivado(): { } { < MODPRIVADO > }
void modPublico(): { } { < MODPUBLICO > }
void opAnd(): { } { < OPAND > }
void opOr(): { } { < OPOR > }
void acessVetor(): { } { < ACESSVETOR > }
void tRep3(): { } { < REP3 > }

