/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  STATIC = true;
}

PARSER_BEGIN(TrucoCompiler)

package truco;

import truco.LexicalException;

public class TrucoCompiler
{
  public static void main(String args []) throws ParseException
  {
    TrucoCompiler parser = new TrucoCompiler(System.in);
    while (true)
    {
      System.out.println("Digite Entrada:");
      System.out.print("-> ");
      try
      {
        switch (parser.main())
        {
          case 0 :
          System.out.println("");
          System.out.println("Tudo certo bolinha");
          break;
          default :
          break;
        }
      }
      catch(LexicalException e)
      {
        System.out.println("");
        System.out.println("Algo de errado não está certo...");
        System.out.println(e.getMessage());
      }
      catch(ParseException e)
      {
		Token token = e.currentToken.next;
		int linha = token.beginLine;
		int coluna = token.beginColumn;

		int[][] expectedSequences = e.expectedTokenSequences;
	    String[] esperados = new String[expectedSequences.length];
	    for (int i = 0; i < expectedSequences.length; i++) {
	        StringBuilder sb = new StringBuilder();
	        for (int kind : expectedSequences[i]) {
	            sb.append(TrucoCompiler.tokenImage[kind]).append(" ");
	        }
	        esperados[i] = sb.toString().trim();
	    }

        System.out.println("");
        System.out.println("Algo de errado não está certo...");
        System.out.println("Erro sintático parceiro:");
        System.out.println("Linha: " + linha);
        System.out.println("Coluna: " + coluna);
        System.out.println("Tu mandou essa bomba: " + token.image);

		if(esperados != null) {
       		System.out.println("Tava esperando tipo: ");
			for(int i = 0; i < esperados.length; i++){
       			System.out.println(esperados[i]);
			}
		}
		break;
      }
      catch (Error e)
      {
        String msg = e.getMessage();
		System.out.println("");
        if(msg.contains("Lexical error")) {
        	System.out.println("Algo de errado não está certo...");
        	String msgPtBr = msg.replace("Lexical error", "Erro Léxico\n")
								.replace("at line", "Linha:")
								.replace(", column",".\n Coluna:")
								.replace("Encountered: ", "\n Tu mandou essa bomba");
			System.out.println(msgPtBr);
        }else {
	        System.out.println("Agora fudeu");
	        System.out.println(e.getMessage());
        }

        break;
      }
      finally
      {
        parser.ReInit(System.in);
      }
    }
  }
}

PARSER_END(TrucoCompiler)

TOKEN_MGR_DECLS : {
    public void LexicalError(boolean EOFSeen, int lexState, int errorLine,
                             int errorColumn, String errorAfter, char curChar) {
        throw new LexicalException(errorLine, errorColumn, curChar, errorAfter);
    }
}

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| < "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n") >
}

TOKEN :
{

  < STARTPROGRAMA	:		"tresehojogo" 			>

| < ABRECHA			:		"desce" 				>
| < FECHAVE			:		"sobe"  				>

| < ABREPAR			:		"passa"					>
| < FECHAPAR		:		"sinal" 				>

| < DECLASSE		:		"carteado" 				>
| <	MODPRIVADO		:		"privado" 				>
| <	MODPUBLICO		:		"publico" 				>
| < THIS			:		"eu" 					>
| < NEW 			:		"novinho" 				>

| < DECLFUNC 		: 		"vai"					>
| < CHAMAFUNC		:		"vem" 					>
| < RETURN			:		"facao" 				>

| < ATRIVAR			:		"receba"				>
| < FIMINST			:		"pato" 					>

| < TIPOINT   	 	: 		"copa"				    >
| < TIPODOUBLE     	: 		"gato"     				>
| < TIPOBOOLEAN   	: 		"mole"	    			>
| < TIPOSTRING 		:		"espadilha"				>
| < TIPOVETOR		:		"manilha" 				>

| < BOOLTRUE		:		"joga"					>
| < BOOLFALSE		:		"corre"					>
| < NULL			:		"nada" 					>
| < ACESSVETOR		:		":" 					>

| < SINALDECIMAL	:		"." 					>
| < SINALSTRING		:		"'"						>


| < SOMA 			: 		"mais" 					>
| < SUBTRACAO 		: 		"menos" 				>
| < DIVISAO 		: 		"div" 					>
| < MULTIPLICACAO 	: 		"mul" 					>

| < OPAND			:		"e"						>
| < OPOR			:		"ou"					>
| < OPMAIOR      	: 		"maior" 				>
| < OPMENOR      	: 		"menor" 				>
| < OPIGUAL      	: 		"igual"					>
| < OPDIF        	: 		"diferente"				>

| < COND			:		"parceiro" 				>
| < FOR 			:		"torna"					>
| < REP3			:		"come3" 				>

| < IDENT 			:		( <LETRA> )( <LETRA> | <DIGITO> )* 		>
| < LETRA			:		[ "A"-"Z" ] | [ "a"-"z" ]				>
| < STRING 			: 		"'" (~["'", "\n", "\r"])+ "'" 			>

| < DECIMAL			:		( <INTEIRO> <SINALDECIMAL> <INTEIRO> )	>
| < INTEIRO 		: 		( <DIGITO> )+ 			>
| < #DIGITO 		: 		[ "0"-"9" ] 			>


}

int main() :
{}
{
  	<STARTPROGRAMA> <ABRECHA>
		(bloco())*
  	<FECHAVE>
  	
	{ return 0; }
}

// TOKEN INVÁLIDO



// OPERADORES

void opArit() :
{}
{
	( <SOMA>
	| <SUBTRACAO>
	| <MULTIPLICACAO>
	| <DIVISAO>
	)
}

void opLog() :
{}
{
	( <OPMAIOR>
	| <OPMENOR>
	| <OPIGUAL>
	| <OPDIF>
	)
}

void opCond() :
{}
{
	( <OPAND>
	| <OPOR>
	)
}

// EXPRESSÕES

void expArit() :
{}
{
   termo() ( opArit() ( <ABREPAR> expArit() <FECHAPAR> | termo() ) )*
}

void expLog() :
{}
{
 	expArit() opLog() expArit()
}

void expCond():
{}
{
   expLog() (opCond() ( <ABREPAR> expCond() <FECHAPAR> | expLog()))*
}

// TIPOS DE DADOS

void tipoDado() :
{}
{
  	( <TIPOINT>
  	| <TIPODOUBLE>
  	| <TIPOBOOLEAN>
  	| <TIPOSTRING>
  	| tipoVetor()
  	)
}

void tipoVetor() :
{}
{
	<TIPOVETOR> tipoDado()
}

// INDENTIFICADORES E DECLARAÇÃO

void identificador() :
{}
{
	<IDENT> [ acessaVetor() ] ( atribui() <FIMINST> )
}

void acessaVetor():
{}
{
	<ACESSVETOR> ( <IDENT> | <INTEIRO> )
}

void declVar() :
{}
{
  tipoDado() <IDENT> [ atribui() ] <FIMINST>
}

void numero() :
{}
{
	[ <SOMA> | <SUBTRACAO> ] ( <DECIMAL> | <INTEIRO> )
}

void termo() :
{}
{
  	( <IDENT> [ acessaVetor() ]
  	| <NULL>
  	| <BOOLTRUE>
	| <BOOLFALSE>
	| <STRING>
	| numero()
	| _chamaFuncao()
	)
}

// ATRIBUIÇÕES

void atribui() :
{}
{
	<ATRIVAR> ( atribuiVetor() | expArit() )
}

void atribuiVetor() :
{}
{
	<ABRECHA> termo() ( <FIMINST> termo() )* <FECHAVE>
}

// CONDICIONAL

void condicional():
{}
{
	<COND> <ABREPAR> expCond() <FECHAPAR> <ABRECHA>
		(bloco())*
	 <FECHAVE>
}

// LAÇOS

void lacoRep() :
{}
{
  <FOR> <ABREPAR> bloco() expLog() <FIMINST> bloco() <FECHAPAR>
  	<ABRECHA>
		(bloco())*
	 <FECHAVE>
}

void lacoRep3() :
{}
{
	<REP3> <ABRECHA> (bloco())* <FECHAVE>
}

// FUNÇÕES

void retorna() :
{}
{
	<RETURN> expArit() <FIMINST>
}

void _chamaFuncao():
{}
{
  <CHAMAFUNC> <IDENT> <ABREPAR> termo() ( <FIMINST> termo() )* <FECHAPAR>
}

void chamaFuncao() :
{}
{
  _chamaFuncao() <FIMINST>
}

void declFuncao() :
{}
{
  <DECLFUNC> tipoDado() <IDENT>
  		<ABREPAR> (declVar())* <FECHAPAR>
		<ABRECHA> (bloco())* <FECHAVE>
}

// CLASSE

void modAcesso() :
{}
{
  ( <MODPRIVADO>
  | <MODPUBLICO>
  )
}

void deClasse() :
{}
{
  <DECLASSE> <IDENT> <ABRECHA>
	( [ modAcesso() ] ( declVar() | declFuncao() ) )*
  <FECHAVE>
}

// BLOCOS

void bloco() :
{}
{
  ( declVar()
  | identificador()
  | condicional()
  | lacoRep()
  | lacoRep3()
  | declFuncao()
  | retorna()
  | chamaFuncao()
  )
}

